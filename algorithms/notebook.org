#+title: Important Algorithms for IOI
#+latex_class: org-report
#+latex_class_options: [9pt]
#+latex_header: \usepackage{diagbox}
#+latex_header: \usepackage[table, dvipsnames]{xcolor}
#+latex_header: \usepackage{parskip}
#+latex_header: \setminted{breaklines=true, style=default}
#+latex_header: \makeatletter
#+latex_header: \def\@makechapterhead#1{%
#+latex_header:  {\parindent \z@ \raggedright \normalfont
#+latex_header:    \ifnum \c@secnumdepth >\m@ne
#+latex_header:        \LARGE\bfseries \thechapter:
#+latex_header:    \fi
#+latex_header:    \interlinepenalty\@M
#+latex_header:    \LARGE \bfseries #1\par\nobreak
#+latex_header:    \vskip 10\p@
#+latex_header:  }}
#+latex_header:\def\@makeschapterhead#1{%
#+latex_header:  {\parindent \z@ \raggedright
#+latex_header:    \normalfont
#+latex_header:    \interlinepenalty\@M
#+latex_header:    \Huge \bfseries  #1\par\nobreak
#+latex_header:    \vskip 10\p@
#+latex_header:  }}
#+latex_header:\makeatother


\newpage

* Introduction

Most problems can be reduced to either one of or a combination of the
algorithms presented in this notebook. While not meant to be as
comprehensive as a set of notes on CLRS, it includes the more
challenging and important programs. Sorters and searchers (with the
exception of binary search, which I struggled with early on) are
omitted since they're basic and C++'s STL implements them well enough.
This notebook focuses majorly on graph algorithms, dynamic
programming, greedy programs, and trees. It assumes familiarity with
C/C++ and basic programming techniques such as arrays/vectors, loops,
lists, iteration, and recursion.

Note that it is bad practice to use the header =bits/stdc++.h=: it is
*not* a standard header, and increases compile time by including
/every/ C++ library, not only the required ones. However, it's okay in
competitive programming since the programs are small and runtime
matters more than compile time. Obviously, if compilation takes too
long, the bottleneck is probably this header.

* Searchers
** Binary Search
   #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
   #+include: "./binary_search.cpp" src cpp

   *Complexity: $O(\log_{2}{n})$*
   A basic algorithm, with a lot of similarity to QuickSort. $r$ and
   $l$ are the indexes of the subarray to search recursively. If $r <$
   $l$ directly return $-1$, the element wasn't found. If not, see if
   the current /mid/ is the element we're looking for. If so, return
   /mid/. Otherwise, recurse on either the LHS or RHS subarray.

\newpage
* Graphs
  Graphs can be represented as adjacency matrices and adjacency lists.
  Most algorithms use adjacency lists. Always write a function
  returning =void= called =add_edge= that adds an edge. It can be
  modified depending on whether the graph is directed and weighted.

** Graph Searchers
*** Breath First Search (BFS)
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+include: "./bfs.cpp" src cpp

    *Complexity: $O(m+n)$*
    Adjacency list representation. Undirected and unweighted in this
    case. Usual declaration using =std::vector<std::vector<int>>= over
    =std::vector<std::list<int>>= since vectors are faster with end
    appends. Add the edges.

    The procedure =bfs= maintains a =deque q=. Start at the =src= node.
    Visit all of its neighbours who are unvisited. (For =src=, this is
    by definition /all/ its neighbours.) Push them into =q= to visit
    later. Pop the =q= and push the unvisited neighbours of the node we
    popped. Keep doing this. At some point, all possible nodes
    visitable from =src= will have been visited, and =q= will be empty.
    We keep track of visited nodes using a standard vector =visited=.

    Note that if we maintain a =parent= vector, that keeps track of
    /from whom/ we visited the current node, we can backtrace the
    vector to get the path from =src= to =dest=. This is by definition
    the shortest path, since BFS doesn't go out of its way to explore
    longer paths: it follows the most direct (least edges) route from
    =src= to =dest=. This means BFS is a shortest path finder for
    unweighted graphs (all edge weights = 1).

*** Depth First Search (DFS)

     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "dfs.cpp" src cpp

     *Complexity: $O(m+n)$*
     DFS maintains a stack. It goes as far along a random path as
     possible, pushing the node it left from into a stack. As soon as
     it reaches the end of a path (i.e., it cannot visit an unvisited
     node), it pops out and tries the same from the previous node it
     left. This stack can be maintained implicitly by recursive calls
     to DFS, as shown in the program.

     Note that DFS *does not* cover shortest paths, but it can be used
     for node numbering: by recording the `time' DFS entered a node
     (started recursively calling its neighbours) and left it (exited
     out of its last remaining neighbour and by extension, the node in
     question).

*** Applications of Graph Searchers
**** Connectivity:
     Some parts of a graph may not be connected to other parts of the
     graph, creating sets of connected nodes. To figure out what
     exactly these sets /are/, run either search from a =src= (say 0).
     Observe the resultant =visited= array. The nodes that have been
     visited are from the first set. Note them down if you need to. Now
     run a search from an unvisited node. The additional nodes visited
     are the second set. Repeat until all nodes are visited, and you'll
     know the connectivity sets of the graph.

**** (TODO) Catching cycles: Using DFS Numbering

     More advanced concept, catches cycles in graphs using the numbers
     DFS assigns as it visits nodes.

** Shortest Paths
*** Single Source: Djikstra's Algorithm
     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "djikstras_algorithm.cpp" src cpp
     Djikstra's algorithm finds the shortest path from =src= to every
     other vertex in the graph. It does so by making the locally
     optimum choice (`greedy'). This results in the correct result by
     induction, since any node that has been visited must have been
     visited by a shortest path, and any extension chooses the
     shortest route to that node.

     Now, our implementation of Djikstra's works just fine, but its
     complexity is $O(n^{2})$, because of the nested loop that
     searches for the minimum element. This is quite simply
     /horrible/, since the loop that's actually doing the work using
     the adjacency list for the edges requires only $O(m)$ time. What
     is done is practice is that a heap or red-black-tree is used so
     that the operations =decrease-key= and =get-min-element= require
     constant time rather than linear. This gives us a speedup to
     complexity $O((n+m)\log{n})$.

     In C++, the STL provides =std::set=, which used a balanced binary
     search tree to manage data, meaning it's perfect in this
     application: to access the minimum element, we only have to call
     =set.begin()=. This is implemented in =GREATESC=, given below.
     Note that we use C++'s inbuilt =pair= instead of defining our own
     =struct node=, since it by default compares the first value
     (weight). This prevents us from having to write a comparator
     function and passing it to =set=.\\

     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "../inoi/iarcsjud/GREATESC.cpp" src cpp

     A good and useful visualisation of Djikstra's algorithm is that
     of a fire starting at $t=0$ at the source, and running along
     every path connected to it at a speed of 1 unit per second. Every
     time it reaches a vertex, note down $t$. That's the shortest path
     distance from =src= to that vertex. This is also useful for
     Djikstra's proof of correctness. Any vertex that is in the set of
     `burnt' vertices has been reached (by induction) via a shortest
     path. The base case is obvious: =dist[src] = 0=. We now visit
     every =unvisited= vertex that's a neighbour of =src=. We choose
     the minimum out of these, meaning we make a locally optimum
     choice, and mark it visited. The two vertices in the =visited=
     set are a shortest path. Why? Assume the vertex added was =A=. It
     was the vertex at minimum distance from =src=. For any other
     path to be a shorter path from =src= to =A=, it will use some
     other neighbour of =src=, plus its own path distance to =A=. But,
     =A= is the closest neighbour of =src=, and is therefore the
     shortest path. Now, follow a similar chain of logic taking =A= as
     the new source. It won't `back-visit' =src= since both are in the
     visited set.

     Note that we simultaneously maintain an array called
     =expected-burn-times= that can be thought of as the update array.
     In the zeroth iteration, all values in this array are $+\infty$.
     In the first iteration, all neighbours of =src= are marked with
     their distance from =src=. If there's a shorter path that comes
     up later, from =A=, or =A='s nearest neighbour, or so on, it's
     updated. This also means $\mathtt{A_i}$'s neighbour selected may not be the
     one with the least absolute distance from it, but instead the one
     with the least value in =unvisited= -- it's greedy. All selected
     vertices are marked visited, and all have been reached by a
     shortest path.

     Visualise as a spreading fire, with times being marked per
     vertex.

*** Single Source, Negative Edge Weights: Bellman-Ford Algorithm
     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "bellman_ford.cpp" src cpp

     Bellman-Ford finds shortest paths when negative edge weights are
     included. Djikstra's algorithm cannot be used for this
     application since in making a locally optimum choice, it may miss
     out on some better path due to a negative weight somewhere. To
     fix this issue, Bellman-Ford `runs' Djikstra $V-1$ times, on the
     set of vertices whose distance is *not* infinity. What this does
     is it updates the direction vector (array) /every/ time a better
     path is found. If a better path isn't found, it can `update' it,
     but that doesn't change the value from its previously optimal
     state. This takes care of Djikstra's central idea -- checking
     each vertex only once -- which also contributes to Djikstra's
     higher efficiency. At best, Bellman-Ford has time complexity
     $O(mn)$ due to the $V-1$ loop.

# Top.sort, All pairs shortest path

** Minimum Spanning Trees

*** What is an MST?

   A *tree* is a connected, acyclic graph. Connected means that there is
   no component (set of vertices) of the graph that *cannot* be
   reached from any other component. An acyclic graph is one where
   there is only one (unique) path from any two vertices $i$ to $j$.\\

   A *spanning tree* is one which includes all vertices of another
   graph $G$, that is, it /spans/ all vertices of this graph.\\

   A *minimum spanning tree* is a spanning tree which spans a weighted
   acyclic graph while costing the /minimum/ in terms of edge weights.

*** Motivation

    MSTs are interesting to, say, a network where every node must be
    connected to every other node with minimum possible cost. Other
    graph optimization problems where a spanning tree with low weight
    is required (generally in many networking problems), such as
    approximation of NP-complete problems and cluster analysis. It's
    also used in handwriting recognition.

*** Prim's Algorithm

    *Outline*

    Select the edge with lowest weight from $G$. Draw the tree. Look
    at the edge weights of neighbours of tree vertices. Select the
    lowest such that the tree will not become acyclic. Run $V-1$
    times.

    Prim's is a greedy algorithm, so we require a proof of
    correctness.\\

    *Proof and Minimum Seperator Lemma*

    Let set $V$ be partitioned into two non-empty sets of vertices $U$
    and $W$, and let $e$ be the edge of minimum weight joining these two
    sets. We claim that every MST must include $e$.

    To prove this by contradiction is easy: assume an edge $e$ joining
    $u$ (a member of $U$) and $w$ (a member of $W$). Let this be the
    smallest edge joining $U$ and $W$.

    Consider some other edge $e'$ joining $U$ and $W$ via path $(u',
    w')$, which is included in some ST.

    Now, the weight of this ST could be reduced by using $e$ instead
    of $e'$ (by definition, $e$ is the edge of minimum weight).
    Therefore, the minimum spanning tree must contain $e$.

    Note that $e'$ *must* be an edge that connects to $u$ and $w$ as
    well (part of the same component): we cannot replace any arbitrary
    edge with $e$.\\

    The correctness of Prim's algorithm is now obvious: we always pick
    the minimum edge when adding an edge to the current tree, which
    must be the MST. Recall that we no longer need to start with the
    edge with globally the lowest weight: we can start with any
    vertex's lowest edge.\\

    *Implementation*

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <bits/stdc++.h>

      struct tree_edge
      {
        int src;
        int dest;
      };

      struct node
      {
        int dest;
        int weight;
      };

      void add_edge(std::vector<std::vector<node>>& g, int src, int dest, int weight)
      {
        g[src].push_back({dest, weight});
        g[dest].push_back({src, weight});
      }

      void prim(std::vector<std::vector<node>>& g, std::vector<tree_edge>& tree_edges)
      {
        std::vector<bool> visited (g.size());
        std::vector<int> nbr (g.size());
        std::vector<int> distance (g.size(), std::numeric_limits<int>::max());

        visited[0] = true;
        distance[0] = 0;

        for (int i = 0; i < g[0].size(); ++i) {
          nbr[g[0][i].dest] = 0;
          distance[g[0][i].dest] = g[0][i].weight;
        }

        for (int i = 1; i < g.size(); ++i) {
          int min = std::numeric_limits<int>::max();
          int u;
          for (int j = 0; j < g.size(); ++j) {
            if (!visited[j]) {
              if (distance[j] < min) {
                min = distance[j];
                u = j;
              }
            }
          }
          visited[u] = true;
          tree_edges.push_back({u, nbr[u]});
          for (int j = 0; j < g[u].size(); ++j) {
            if (!visited[g[u][j].dest]) {
              if (distance[g[u][j].dest] > g[u][j].weight) {
                distance[g[u][j].dest] = g[u][j].weight;
                nbr[g[u][j].dest] = u;
              }
            }
          }
        }
      }

      int main()
      {
        int V = 7;
        std::vector<std::vector<node>> g (V);
        add_edge(g,0,1,10);
        add_edge(g,0,2,18);
        add_edge(g,1,2,6);
        add_edge(g,2,3,70);
        add_edge(g,1,4,20);
        add_edge(g,4,6,10);
        add_edge(g,4,5,10);
        add_edge(g,5,6,5);

        std::vector<tree_edge> tree_edges;
        prim(g, tree_edges);

        for (auto x: tree_edges) {
          std::cout << x.src << " " << x.dest << "\n";
        }
        return 0;
      }



    #+END_SRC

    #+RESULTS:
    | 1 | 0 |
    | 2 | 1 |
    | 4 | 1 |
    | 5 | 4 |
    | 6 | 5 |
    | 3 | 2 |


    Note that this is exactly like Djikstra's algorithm, albeit with a
    different update function and with recording the tree in a vector
    called =tree_edges=. Again, this implementation doesn't use a heap
    for the =min_find= operation, which would reduce the complexity
    from $O(n^{2})$ to $O((m+n)\log{n})$.

*** Kruskal's Algorithm
    *Outline*

    Pick edges in ascending order, and add them to the tree. The tree
    will initially not necessarily be connected. Keep adding edges in
    ascending order, then connect the components.\\

    *Proof*

    Kruskal's algorithm involves merging disjoint components of a
    graph. During this =merge= operation, Kruskal's algorithm selects
    the globally minimum edge that *does not form a cycle.* This means
    that adding this edge is the equivalent of the edge chosen by the
    minimum seperator lemma: it's joining two disjoint components
    using the shortest possible edge.\\

    *Implementation*

     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+BEGIN_SRC cpp :eval no-export :exports both
       #include <bits/stdc++.h>


     #+END_SRC

     #+RESULTS:

\newpage
* Dynamic Programming
** Fibonacci
   $$T_{0} = 0, T_{1} = 1$$
   $$T_{n} = T_{n-1} + T_{n-2}$$
*** Memoized
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+include: "./memoized_fibonacci.cpp" src cpp
*** DP
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+include: "./dp_fibonacci.cpp" src cpp
** Grid Paths
   Interesting problem: given a grid:
   #+ATTR_LATEX: :align |c|c|c|c|c|
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|

   We want to go from $(0,0)$ to $(5,10)$. How many ways are there of
   doing this? (Only up and right moves allowed.)

*** Combinatorics
    15 moves must be made in /all/ possible paths. 5 of these will be
    horizontal, and the rest vertical. Or, if we were to write moves
    using the notation $\uparrow \rightarrow$, selecting only
    rightward moves:
    $$...\textunderscore\rightarrow\textunderscore\rightarrow\textunderscore\rightarrow\rightarrow\rightarrow\textunderscore...$$

    Clearly, we must select any 5 spots out of 15, or, equivalently,
    any 10 spots out of 15. Our solution is: $${15\choose 5} =
    {15\choose 10} = 3003$$

*** Induction

    Consider an intersection $(i,j)$. How did we get here? Either from
    $(i-1,j)$ or $(i,j-1)$. Therefore,
    $$p(i,j) = p(i-1,j) + p(i,j-1)$$
    where $p()$ is a function that returns number of paths.
    It's always important to check boundary cases, because things
    often change there.

    $$p(i,0) = p(i-1,0)$$
    $$p(0,j) = p(0,j-1)$$

    And they do, there's no $-1$ position. In fact, this'll probably
    mess things up in a language like Python where $-1$ refers to the
    /last/ element of an array. Anyway, the base case becomes:

    $$p(0,0)=1$$

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <iostream>

      int naive_recursion_path(int i, int j)
      {
        if (i == 0 && j == 0) {
          return 1;
        }
        if (i == 0) {
          return naive_recursion_path(0,j-1);
        }
        if (j == 0) {
          return naive_recursion_path(i-1,0);
        }
        return naive_recursion_path(i-1,j) + naive_recursion_path(i,j-1);
      }

      int main()
      {
        std::cout << naive_recursion_path(5,10) << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    : 3003

    We get the correct answer. The clever will recognize this grid as
    a Pascal's triangle, with $(0,0)$ as the root vertex. This further
    substantiates our claim of $15\choose 5$: it's a binomial
    coefficient of the 15th level.

*** Holes
    This is where the problem gets tricky: holes.
   #+ATTR_LATEX: :align |c|c|c|c|c|
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|

   Assume you cannot use the intersection at $(2,4)$. Resolving it
   using combinatorics, we remove paths from $(0,0)$ to $(2,4)$ and
   from $(2,4)$ to $(5,10)$. We then multiply these to get all
   possible combinations, and subtract these from 3003.

   $${15\choose 5} - {6\choose 2} \times {9\choose 3} = 3003 - 1260 = 1743$$

   It is obvious that this problem becomes difficult for two holes
   onward, since we may have to use the inclusion-exclusion principle
   to remove overlaps, extra counts, or undercounts. Consider an extra
   hole at $(4,4)$.
  #+ATTR_LATEX: :align |c|c|c|c|c|
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|

  The overlaps make this an annoying problem to solve. This is,
  however, incredibly simple with the inductive/recursive approach:
  just set the paths function to return 0 at the intersections where
  holes exist.

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <iostream>

      int naive_recursion_path(int i, int j)
      {
        if (i == 2 && j == 4) {
          return 0;
        }
        if (i == 0 && j == 0) {
          return 1;
        }
        if (i == 0) {
          return naive_recursion_path(0,j-1);
        }
        if (j == 0) {
          return naive_recursion_path(i-1,0);
        }
        return naive_recursion_path(i-1,j) + naive_recursion_path(i,j-1);
      }

      int main()
      {
        std::cout << naive_recursion_path(5,10) << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    : 1743

    Naturally, we can define an arbitrary number of holes this way.

*** DP
    It is obvious that the naive recursion approach recalculates many
    values in the table. To reduce the complexity, we can use both
    memoization or DP. DP is generally faster, although there are some
    cases where a top-down memoized approach /may/ be better. (An
    example is given later.)

    As we do in DP, we must first reduce the problem to a DAG, then
    solve it in topological order *iteratively*. This is obvious, it's the same
    grid, with arrows pointing up and right in each cell. Therefore,
    the bottom left intersection, $(0,0)$ is where we start, working
    column by column, row by row, or diagonal by diagonal. For the
    sake of this program, let's use row by row.

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <bits/stdc++.h>

      int dp_path(int p, int q)
      {
        int i = p+1;
        int j = q+1;
        int dp[j][i];

        for (int l = 0; l < i; ++l) {
          dp[0][l] = 1;
        }

        for (int l = 0; l < j; ++l) {
          dp[l][0] = 1;
        }

        for (int l = 1; l < j; ++l) {
          for (int k = 1; k < i; ++k) {
            dp[l][k] = dp[l-1][k] + dp[l][k-1];
          }
        }
        return dp[q][p];
      }

      int main()
      {
        std::cout << dp_path(5,10) << "\n";
        return 0;
      }
    #+END_SRC

    #+RESULTS:
    : 3003

    We can now add holes, thus.
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <bits/stdc++.h>

      int dp_path(int p, int q)
      {
        int i = p+1;
        int j = q+1;
        int dp[j][i];

        for (int l = 0; l < i; ++l) {
          dp[0][l] = 1;
        }

        for (int l = 0; l < j; ++l) {
          dp[l][0] = 1;
        }

        for (int l = 1; l < j; ++l) {
          for (int k = 1; k < i; ++k) {
            dp[l][k] = dp[l-1][k] + dp[l][k-1];
            if (l == 4 && k == 2) {
              dp[l][k] = 0;
            }
          }
        }
        return dp[q][p];
      }

      int main()
      {
        std::cout << dp_path(5,10) << "\n";
        return 0;
      }
    #+END_SRC

    #+RESULTS:
    : 1743

    With the additional hole at $(4,4)$:

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <bits/stdc++.h>

      int dp_path(int p, int q)
      {
        int i = p+1;
        int j = q+1;
        int dp[j][i];

        for (int l = 0; l < i; ++l) {
          dp[0][l] = 1;
        }

        for (int l = 0; l < j; ++l) {
          dp[l][0] = 1;
        }

        for (int l = 1; l < j; ++l) {
          for (int k = 1; k < i; ++k) {
            dp[l][k] = dp[l-1][k] + dp[l][k-1];
            if ((l == 4 && k == 2) || (l == 4 && k == 4)) {
              dp[l][k] = 0;
            }
          }
        }
        return dp[q][p];
      }

      int main()
      {
        std::cout << dp_path(5,10) << "\n";
        return 0;
      }
    #+END_SRC

    #+RESULTS:
    : 1358

** Longest Common
*** Subword
   Consider two strings:
   $$u = a_{1}a_{2}\hdots a_{n}$$
   $$v = b_{1}b_{2}\hdots b_{m}$$

   Our task is to find the longest common (contiguous) substring of these two
   strings, that is, /k/ for some

   $$a_{i}\hdots a_{i+k-1} = b_{j}\hdots b_{j+k-1}$$

   This is inherently an extremely recursive/inductive problem.
   Consider a function $l()$ returning the length of the longest
   common substring. Then,

   \[l(i,j) = \begin{cases}
      0 &  a_{i} \neq b_{j}\\
      1+ l(i+1,j+1) & a_{i} = b_{j}
   \end{cases}
   \]

   where $i$ and $j$ are the indexes of the strings we're checking. We
   must, however, also define boundary cases, for when we reach the
   end of either string.

   $$l(n+1,j) = 0$$
   $$l(i,m+1) = 0$$

   Now, the structure of this problem means that when we try to solve
   it using DP, we will need the result of $l(i+1,j+1)$ before we can
   find $l(i,j)$. Therefore, we create a DP matrix, which looks like
   this:

   #+ATTR_LATEX: :align |c|c||c|c|c|c|c|c|c|
   |---+---------------+---+---+---+---+---+---+---------------|
   |   |               | 0 | 1 | 2 | 3 | 4 | 5 |             6 |
   |---+---------------+---+---+---+---+---+---+---------------|
   |   |               | s | e | c | r | e | t | $\varnothing$ |
   |---+---------------+---+---+---+---+---+---+---------------|
   |---+---------------+---+---+---+---+---+---+---------------|
   | 0 | b             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 1 | i             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 2 | s             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 3 | e             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 4 | c             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 5 | t             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 6 | $\varnothing$ |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|

   We can fill it up starting from the bottom right corner. This time,
   let's fill it up column by column, after initialising the boundary
   cases. The completed matrix is:

   #+ATTR_LATEX: :align |cc|ccccccc|
   |-----+-----------------+-----+-----+-----+-----+-----+-----+-----------------|
   |     |                 | *0* | *1* | *2* | *3* | *4* | *5* |             *6* |
   |     |                 | *s* | *e* | *c* | *r* | *e* | *t* | *$\varnothing$* |
   |-----+-----------------+-----+-----+-----+-----+-----+-----+-----------------|
   | *0* | *b*             |   0 |   0 |   0 |   0 |   0 |   0 |               0 |
   | *1* | *i*             |   0 |   0 |   0 |   0 |   0 |   0 |               0 |
   | *2* | *s*             | *3* |   0 |   0 |   0 |   0 |   0 |               0 |
   | *3* | *e*             |   0 |   2 |   0 |   0 |   1 |   0 |               0 |
   | *4* | *c*             |   0 |   0 |   1 |   0 |   0 |   0 |               0 |
   | *5* | *t*             |   0 |   0 |   0 |   0 |   0 |   1 |               0 |
   | *6* | *$\varnothing$* |   0 |   0 |   0 |   0 |   0 |   0 |               0 |
   |-----+-----------------+-----+-----+-----+-----+-----+-----+-----------------|

   Putting this into C++:

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <iostream>
      #include <cstring>

      int lcw(char *u, char *v)
      {
        int p = strlen(v);
        int q = strlen(u);
        int dp[p + 1][q + 1];
        for (int i = 0; i < p+1; ++i) {
          dp[i][q] = 0;
        }
        for (int i = 0; i < q+1; ++i) {
          dp[p][i] = 0;
        }
        int greatest = 0;
        for (int i = q-1; i >= 0; --i) {
          for (int j = p-1; j >= 0; --j) {
            if (u[i] == v[j]) {
              dp[j][i] = 1 + dp[j+1][i+1];
              if (dp[j][i] > greatest) {
                greatest = dp[j][i];
              }
            }
            else {
              dp[j][i] = 0;
            }
          }
        }
        for (int i = 0; i < p+1; ++i) {
          for (int j = 0; j < q+1; ++j) {
            std::cout << dp[i][j] << " ";
          }
          std::cout << "\n";
        }
        return greatest;
      }

      int main()
      {
        std::cout << lcw("secret", "bisect") << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
    | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
    | 3 | 0 | 0 | 0 | 0 | 0 | 0 |
    | 0 | 2 | 0 | 0 | 1 | 0 | 0 |
    | 0 | 0 | 1 | 0 | 0 | 0 | 0 |
    | 0 | 0 | 0 | 0 | 0 | 1 | 0 |
    | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
    | 3 |   |   |   |   |   |   |

    The complexity of this solution is $O(mn)$.

*** Subsequence
    Our task is to find the longest non-contiguous common letter
    sequence. For example, in =bisect= and =secret=, the longest
    subsequence is =sect=.


    Now, this problem is a bit gnarly. The trick is to realise one
    crucial point, illustrated below.


    | a_0 | a_1 | a_2 | a_3 | a_4 | a_5 |
    | b_0 | b_1 | b_2 | b_3 | b_4 | b_5 |

    *Cases:*

    1. If a_0 and b_0 match, it's all good, and we can continue to
       check for a_1 and b_1, and so on. This is similar to our first
       inductive conclusion in longest subword.
       | \color{ForestGreen} a_0 | a_1 | a_2 | a_3 | a_4 | a_5 |
       | \color{ForestGreen} b_0 | b_1 | b_2 | b_3 | b_4 | b_5 |

    2. If a_0 and b_0 do *not* match, we cannot discard either of
       them. This is because a_0 may match with some other b_j, or b_0
       may match with some other a_i:
       | \color{ForestGreen} a_0 | a_1 | a_2                     | a_3 | a_4 | a_5 |
       | \color{red} b_0         | b_1 | \color{ForestGreen} b_2 | b_3 | b_4 | b_5 |

       | \color{red} a_0         | a_1 | a_2 | \color{ForestGreen} a_3 | a_4 | a_5 |
       | \color{ForestGreen} b_0 | b_1 | b_2 | b_3                     | b_4 | b_5 |

       The two cases are either ignoring a_0 or b_0, not both, and
       checking forward. This can be done inductively, always checking
       for the next index onward with one of the values preserved.
       This can also be thought of as maintaining (say) a_0 `shifting'
       string b leftwards one unit, then rechecking, treating this new
       shifted string as a new string. This must be done for both,
       that is, we must check shifts for both strings.

       We must therefore check /both/, and choose the maximum out of
       them (recall that we are choosing the maximum length
       subsequence, so it's okay to forget about ones with shorter length).

    3. Naturally, the boundary/edge cases remain the same.

    Our function, $L()$, therefore, has the following cases:

   \[L(i,j) = \begin{cases}
      1+ L(i+1,j+1) & a_{i} = b_{j}\\
      \mathrm{max}(L(i+1,j),L(i,j+1)) & a_{i} \neq b_{j}
   \end{cases}
   \]

   The edge cases remain the same:

   $$L(n+1,j) = 0$$
   $$L(i,m+1) = 0$$

   Again, we can build a matrix that looks a lot like the previous
   one, with dependencies in three directions: a call to $L(i,j)$
   needs to check the maximum on the right and below as well as know
   what's in $(i+1,j+1)$.

   #+ATTR_LATEX: :align |c|c||c|c|c|c|c|c|c|
   |---+---------------+---+---+---+---+---+---+---------------|
   |   |               | 0 | 1 | 2 | 3 | 4 | 5 |             6 |
   |---+---------------+---+---+---+---+---+---+---------------|
   |   |               | s | e | c | r | e | t | $\varnothing$ |
   |---+---------------+---+---+---+---+---+---+---------------|
   |---+---------------+---+---+---+---+---+---+---------------|
   | 0 | b             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 1 | i             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 2 | s             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 3 | e             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 4 | c             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 5 | t             |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|
   | 6 | $\varnothing$ |   |   |   |   |   |   |               |
   |---+---------------+---+---+---+---+---+---+---------------|

   Filling it up as a DP:
   #+ATTR_LATEX: :align |cc|ccccccc|
   |-----+-----------------+-----+-----+-----+-----+-----+-----+-----------------|
   |     |                 | *0* | *1* | *2* | *3* | *4* | *5* |             *6* |
   |     |                 | *s* | *e* | *c* | *r* | *e* | *t* | *$\varnothing$* |
   |-----+-----------------+-----+-----+-----+-----+-----+-----+-----------------|
   | *0* | *b*             |   4 |   3 |   2 |   2 |   2 |   1 |               0 |
   | *1* | *i*             |   4 |   3 |   2 |   2 |   2 |   1 |               0 |
   | *2* | *s*             |   4 |   3 |   2 |   2 |   2 |   1 |               0 |
   | *3* | *e*             |   3 |   3 |   2 |   2 |   2 |   1 |               0 |
   | *4* | *c*             |   2 |   2 |   2 |   1 |   1 |   1 |               0 |
   | *5* | *t*             |   1 |   1 |   1 |   1 |   1 |   1 |               0 |
   | *6* | *$\varnothing$* |   0 |   0 |   0 |   0 |   0 |   0 |               0 |
   |-----+-----------------+-----+-----+-----+-----+-----+-----+-----------------|

   Note that we can just look at the value of $(0,0)$ to get the
   answer, since the maximum propagates to the top and left. We don't
   have to explicitly maintain a =max= variable.

   Expressing this in C++:
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <iostream>
      #include <cstring>
      #include <algorithm>

      int lcs(char *u, char *v)
      {
        int p = strlen(v);
        int q = strlen(u);
        int dp[p + 1][q + 1];
        for (int i = 0; i < p+1; ++i) {
          dp[i][q] = 0;
        }
        for (int i = 0; i < q+1; ++i) {
          dp[p][i] = 0;
        }
        for (int i = q-1; i >= 0; --i) {
          for (int j = p-1; j >= 0; --j) {
            if (u[i] == v[j]) {
              dp[j][i] = 1 + dp[j+1][i+1];
            }
            else {
              dp[j][i] = std::max(dp[j+1][i], dp[j][i+1]);
            }
          }
        }
        for (int i = 0; i < p+1; ++i) {
          for (int j = 0; j < q+1; ++j) {
            std::cout << dp[i][j] << " ";
          }
          std::cout << "\n";
        }
        return dp[0][0];
      }
      int main()
      {
        std::cout << lcs("secret", "bisect") << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    | 4 | 3 | 2 | 2 | 2 | 1 | 0 |
    | 4 | 3 | 2 | 2 | 2 | 1 | 0 |
    | 4 | 3 | 2 | 2 | 2 | 1 | 0 |
    | 3 | 3 | 2 | 2 | 2 | 1 | 0 |
    | 2 | 2 | 2 | 1 | 1 | 1 | 0 |
    | 1 | 1 | 1 | 1 | 1 | 1 | 0 |
    | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
    | 4 |   |   |   |   |   |   |

    This program also runs in $O(mn)$ time.

** Edit Distance
   The edit distance between two strings is merely how many operations
   apart they are. This naturally varies according to which operations
   are allowed. For our study, we use Levenshtein distance, that is,
   the allowed operations are:
   1. Insert a letter.
   2. Delete a letter.
   3. Substitute a single letter with another one.

   Converting this to an inductive definition, for a function $E()$
   returning the edit distance, is the following.

    | a_0 | a_1 | a_2 | a_3 | a_4 | a_5 |
    | b_0 | b_1 | b_2 | b_3 | b_4 | b_5 |

   1. If a_0 = b_0, there's nothing to do (no edits to be made), move
      on to $E(i+1,j+1)$.
   2. If a_0 $\neq$ b_0,
      a. We can substitute one for the other, and move on. This should
         return $1 + E(i+1,j+1)$.
      b. We can delete a_0. The function should then return $1+E(i+1,j)$.
      c. We can insert b_0 at $i-1$ in a, meaning we now must find $1+
         E(i,j+1)$.

   This is pretty similar to the definition for $L()$, with the
   exception that we will seek the minimum value for (2) rather than
   the maximum, since we want the /minimum/ edit distance.

   \[E(i,j) = \begin{cases}
      E(i+1,j+1) & a_{i} = b_{j}\\
      1+\mathrm{min}(E(i+1,j+1),E(i+1,j),E(i,j+1)) & a_{i} \neq b_{j}
   \end{cases}
   \]

   The edge cases, however, have a major change. This is because of
   the fact that the edit distance between a $\varnothing$ string and
   a string of non-negative length is the length of the non-null
   string. Therefore,

   $$E(n+1,j) = m-j+1$$
   $$E(i,m+1) = n-i+1$$


   We skip to writing the code for this example, since the matrices
   are very similar to the previous problems, with the exception that
   on a mismatch, we seek to add the minimum of the surrounding three
   values with one. In C++,

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :eval no-export :exports both
      #include <iostream>
      #include <cstring>
      #include <algorithm>

      int ed(char *u, char *v)
      {
        int p = strlen(v);
        int q = strlen(u);
        int dp[p + 1][q + 1];
        for (int i = 0; i < p+1; ++i) {
          dp[i][q] = p-i;
        }
        for (int i = 0; i < q+1; ++i) {
          dp[p][i] = q-i;
        }
        for (int i = q-1; i >= 0; --i) {
          for (int j = p-1; j >= 0; --j) {
            if (u[i] == v[j]) {
              dp[j][i] = dp[j+1][i+1];
            }
            else {
              dp[j][i] = 1 + std::min(dp[j+1][i+1], std::min(dp[j+1][i], dp[j][i+1]));
            }
          }
        }
        for (int i = 0; i < p+1; ++i) {
          for (int j = 0; j < q+1; ++j) {
            std::cout << dp[i][j] << " ";
          }
          std::cout << "\n";
        }
        return dp[0][0];
      }
      int main()
      {
        std::cout << ed("secret", "bisect") << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    | 4 | 4 | 4 | 4 | 4 | 5 | 6 |
    | 3 | 4 | 3 | 3 | 3 | 4 | 5 |
    | 2 | 3 | 3 | 2 | 2 | 3 | 4 |
    | 3 | 2 | 3 | 2 | 1 | 2 | 3 |
    | 4 | 3 | 2 | 2 | 1 | 1 | 2 |
    | 5 | 4 | 3 | 2 | 1 | 0 | 1 |
    | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    | 4 |   |   |   |   |   |   |

*** A Note on Backtracking and Space Complexity
    To find the actual /edits/ or the actual subsequence, we must
    backtrace in the matrix. This is done simply by taking our answer,
    and figuring out how we got there. This is easy for subwords,
    since we can also return the position where the last match was,
    and simply read the subword from either of the strings. However,
    for subsequences and edit distances, this can be harder. Consider
    our last edit matrix,

   #+ATTR_LATEX: :align c|cccccccc
    |               |   s | e | c | r | e | t | $\varnothing$ |
    |---------------+-----+---+---+---+---+---+---------------|
    | b             | *4* | 4 | 4 | 4 | 4 | 5 |             6 |
    | i             |   3 | 4 | 3 | 3 | 3 | 4 |             5 |
    | s             |   2 | 3 | 3 | 2 | 2 | 3 |             4 |
    | e             |   3 | 2 | 3 | 2 | 1 | 2 |             3 |
    | c             |   4 | 3 | 2 | 2 | 1 | 1 |             2 |
    | t             |   5 | 4 | 3 | 2 | 1 | 0 |             1 |
    | $\varnothing$ |   6 | 5 | 4 | 3 | 2 | 1 |             0 |

    We start from position $(0,0)$. How could we have gotten there?
    Since s $\neq$ b, it must have been by taking the minimum element
    around it, and adding 1. Clearly, we got there from the 3 below.
    From there, again, we came from 2. From 2, since s $=$ s, we came
    from the 2 diagonal to it. Again, e $=$ e, and c $=$ c. We then
    move two spaces left, reaching t $=$ t. Finally, we reach the
    bottom left corner.
   #+ATTR_LATEX: :align c|cccccccc
    | \backslashbox{v}{u} |   s |   e |   c |   r |   e |   t | $\varnothing$ |
    |---------------------+-----+-----+-----+-----+-----+-----+---------------|
    | b                   | *4* |   4 |   4 |   4 |   4 |   5 |             6 |
    | i                   | *3* |   4 |   3 |   3 |   3 |   4 |             5 |
    | s                   | *2* |   3 |   3 |   2 |   2 |   3 |             4 |
    | e                   |   3 | *2* |   3 |   2 |   1 |   2 |             3 |
    | c                   |   4 |   3 | *2* |   2 |   1 |   1 |             2 |
    | t                   |   5 |   4 |   3 | *2* | *1* | *0* |             1 |
    | $\varnothing$       |   6 |   5 |   4 |   3 |   2 |   1 |           *0* |

   From this, the sequence of moves is easy to compute, a vertical
   downward move is deleting a letter from $v$. A horizontal rightward
   move is deleting a letter from $u$, or inserting a letter into $v$.
   A diagonal move can be one of two cases: if the two letters were
   equal, it's the null move, it does nothing. If the two letters were
   unequal, it was a substitution. Our complete traceback is
   therefore:

   1. Delete `b' from _\texttt{b}_\texttt{isect}.
   2. Delete `i' _\texttt{i}_\texttt{sect}.
   3. Insert `r' into =sec_t=.
   4. Insert `e' into =secr_t=.

   We therefore have edited =bisect= to =secret= in 4 moves.\\

   On space complexity: the current space complexity is $O(mn)$, since
   we're storing the whole matrix. However, as in many DP problems,
   this isn't necessary. We only need two rows or columns at a time.
   This means that if we really want to optimize for space, we can
   basically forget about all but the column (or row) we're currently
   operating on. This will prevent a post-write traceback, we must
   record the moves we make as we write the two arrays. This method
   has space complexity $O(m)$ or $O(n)$. Whichever is smaller among
   $m$ and $n$ can be used, minimising space complexity.
