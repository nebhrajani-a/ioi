#+title: Important Algorithms for IOI
#+latex_class_options: [9pt]
#+latex_header: \usepackage[table]{xcolor}
#+latex_header: \setlength\parindent{0pt}
#+latex_header: \setminted{breaklines=true, style=default}

\newpage

* Introduction

Most problems can be reduced to either one of or a combination of the
algorithms presented in this notebook. While not meant to be as
comprehensive as a set of notes on CLRS, it includes the more
challenging and important programs. Sorters and searchers (with the
exception of binary search, which I struggled with early on) are
omitted since they're basic and C++'s STL implements them well enough.
This notebook focuses majorly on graph algorithms, dynamic
programming, greedy programs, and trees. It assumes familiarity with
C/C++ and basic programming techniques such as arrays/vectors, loops,
lists, iteration, and recursion.

Note that it is bad practice to use the header =bits/stdc++.h=: it is
*not* a standard header, and increases compile time by including
/every/ C++ library, not only the required ones. However, it's okay in
competitive programming since the programs are small and runtime
matters more than compile time. Obviously, if compilation takes too
long, the bottleneck is probably this header.

* Searchers
** Binary Search
   #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
   #+include: "./binary_search.cpp" src cpp

   *Complexity: $O(\log_{2}{n})$*
   A basic algorithm, with a lot of similarity to QuickSort. $r$ and
   $l$ are the indexes of the subarray to search recursively. If $r <$
   $l$ directly return $-1$, the element wasn't found. If not, see if
   the current /mid/ is the element we're looking for. If so, return
   /mid/. Otherwise, recurse on either the LHS or RHS subarray.

* Graphs
  Graphs can be represented as adjacency matrices and adjacency lists.
  Most algorithms use adjacency lists. Always write a function
  returning =void= called =add_edge= that adds an edge. It can be
  modified depending on whether the graph is directed and weighted.

** Graph Searchers
*** Breath First Search (BFS)
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+include: "./bfs.cpp" src cpp

    *Complexity: $O(m+n)$*
    Adjacency list representation. Undirected and unweighted in this
    case. Usual declaration using =std::vector<std::vector<int>>= over
    =std::vector<std::list<int>>= since vectors are faster with end
    appends. Add the edges.

    The procedure =bfs= maintains a =deque q=. Start at the =src= node.
    Visit all of its neighbours who are unvisited. (For =src=, this is
    by definition /all/ its neighbours.) Push them into =q= to visit
    later. Pop the =q= and push the unvisited neighbours of the node we
    popped. Keep doing this. At some point, all possible nodes
    visitable from =src= will have been visited, and =q= will be empty.
    We keep track of visited nodes using a standard vector =visited=.

    Note that if we maintain a =parent= vector, that keeps track of
    /from whom/ we visited the current node, we can backtrace the
    vector to get the path from =src= to =dest=. This is by definition
    the shortest path, since BFS doesn't go out of its way to explore
    longer paths: it follows the most direct (least edges) route from
    =src= to =dest=. This means BFS is a shortest path finder for
    unweighted graphs (all edge weights = 1).

*** Depth First Search (DFS)

     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "dfs.cpp" src cpp

     *Complexity: $O(m+n)$*
     DFS maintains a stack. It goes as far along a random path as
     possible, pushing the node it left from into a stack. As soon as
     it reaches the end of a path (i.e., it cannot visit an unvisited
     node), it pops out and tries the same from the previous node it
     left. This stack can be maintained implicitly by recursive calls
     to DFS, as shown in the program.

     Note that DFS *does not* cover shortest paths, but it can be used
     for node numbering: by recording the `time' DFS entered a node
     (started recursively calling its neighbours) and left it (exited
     out of its last remaining neighbour and by extension, the node in
     question).

*** Applications of Graph Searchers
**** Connectivity:
     Some parts of a graph may not be connected to other parts of the
     graph, creating sets of connected nodes. To figure out what
     exactly these sets /are/, run either search from a =src= (say 0).
     Observe the resultant =visited= array. The nodes that have been
     visited are from the first set. Note them down if you need to. Now
     run a search from an unvisited node. The additional nodes visited
     are the second set. Repeat until all nodes are visited, and you'll
     know the connectivity sets of the graph.

**** (TODO) Catching cycles: Using DFS Numbering
     More advanced concept, catches cycles in graphs using the numbers
     DFS assigns as it visits nodes.

** Shortest Paths
*** Single Source: Djikstra's Algorithm
     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "djikstras_algorithm.cpp" src cpp
     Djikstra's algorithm finds the shortest path from =src= to every
     other vertex in the graph. It does so by making the locally
     optimum choice (`greedy'). This results in the correct result by
     induction, since any node that has been visited must have been
     visited by a shortest path, and any extension chooses the
     shortest route to that node.

     Now, our implementation of Djikstra's works just fine, but its
     complexity is $O(n^{2})$, because of the nested loop that
     searches for the minimum element. This is quite simply
     /horrible/, since the loop that's actually doing the work using
     the adjacency list for the edges requires only $O(m)$ time. What
     is done is practice is that a heap or red-black-tree is used so
     that the operations =decrease-key= and =get-min-element= require
     constant time rather than linear. This gives us a speedup to
     complexity $O((n+m)\log{n})$.

     In C++, the STL provides =std::set=, which used a balanced binary
     search tree to manage data, meaning it's perfect in this
     application: to access the minimum element, we only have to call
     =set.begin()=. This is implemented in =GREATESC=, given below.
     Note that we use C++'s inbuilt =pair= instead of defining our own
     =struct node=, since it by default compares the first value
     (weight). This prevents us from having to write a comparator
     function and passing it to =set=.\\

     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "../inoi/iarcsjud/GREATESC.cpp" src cpp

     A good and useful visualisation of Djikstra's algorithm is that
     of a fire starting at $t=0$ at the source, and running along
     every path connected to it at a speed of 1 unit per second. Every
     time it reaches a vertex, note down $t$. That's the shortest path
     distance from =src= to that vertex. This is also useful for
     Djikstra's proof of correctness. Any vertex that is in the set of
     `burnt' vertices has been reached (by induction) via a shortest
     path. The base case is obvious: =dist[src] = 0=. Now, when any
     vertex wants to be added to the =visited= set, it must be an
     unvisited neighbour of =src=. It does this by choosing the
     locally best path to do so, which in this case is either the
     direct edge or through one of the previous neighbours. Since
     Djikstra's algorithm only marks a node visited when it /reaches/
     the node, it'll check its nearness to every one of its
     neighbours.

*** Single Source, Negative Edge Weights: Bellman-Ford Algorithm
     #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
     #+include: "bellman_ford.cpp" src cpp

     Bellman-Ford finds shortest paths when negative edge weights are
     included. Djikstra's algorithm cannot be used for this
     application since in making a locally optimum choice, it may miss
     out on some better path due to a negative weight somewhere. To
     fix this issue, Bellman-Ford `runs' Djikstra $V-1$ times, on the
     set of vertices whose distance is *not* infinity. What this does
     is it updates the direction vector (array) /every/ time a better
     path is found. If a better path isn't found, it can `update' it,
     but that doesn't change the value from its previously optimal
     state. This takes care of Djikstra's central idea -- checking
     each vertex only once -- which also contributes to Djikstra's
     higher efficiency. At best, Bellman-Ford has time complexity
     $O(mn)$ due to the $V-1$ loop.


* Dynamic Programming
** Fibonacci
   $$T_{0} = 0, T_{1} = 1$$
   $$T_{n} = T_{n-1} + T_{n-2}$$
*** Memoized
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+include: "./memoized_fibonacci.cpp" src cpp
*** DP
    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+include: "./dp_fibonacci.cpp" src cpp
** Grid Paths
   Interesting problem: given a grid:
   #+ATTR_LATEX: :align |c|c|c|c|c|
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|
   |   |   |   |   |   |
   |---+---+---+---+---|

   We want to go from $(0,0)$ to $(5,10)$. How many ways are there of
   doing this? (Only up and right moves allowed.)

*** Combinatorics
    15 moves must be made in /all/ possible paths. 5 of these will be
    horizontal, and the rest vertical. Or, if we were to write moves
    using the notation $\uparrow \rightarrow$, selecting only
    rightward moves:
    $$...\textunderscore\rightarrow\textunderscore\rightarrow\textunderscore\rightarrow\rightarrow\rightarrow\textunderscore...$$

    Clearly, we must select any 5 spots out of 15, or, equivalently,
    any 10 spots out of 15. Our solution is: $${15\choose 5} =
    {15\choose 10} = 3003$$

*** Induction

    Consider an intersection $(i,j)$. How did we get here? Either from
    $(i-1,j)$ or $(i,j-1)$. Therefore,
    $$p(i,j) = p(i-1,j) + p(i,j-1)$$
    where $p()$ is a function that returns number of paths.
    It's always important to check boundary cases, because things
    often change there.

    $$p(i,0) = p(i-1,0)$$
    $$p(0,j) = p(0,j-1)$$

    And they do, there's no $-1$ position. In fact, this'll probably
    mess things up in a language like Python where $-1$ refers to the
    /last/ element of an array. Anyway, the base case becomes:

    $$p(0,0)=1$$

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :exports both
      #include <iostream>

      int naive_recursion_path(int i, int j)
      {
        if (i == 0 && j == 0) {
          return 1;
        }
        if (i == 0) {
          return naive_recursion_path(0,j-1);
        }
        if (j == 0) {
          return naive_recursion_path(i-1,0);
        }
        return naive_recursion_path(i-1,j) + naive_recursion_path(i,j-1);
      }

      int main()
      {
        std::cout << naive_recursion_path(5,10) << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    : 3003

    We get the correct answer. The clever will recognize this grid as
    a Pascal's triangle, with $(0,0)$ as the root vertex. This further
    substantiates our claim of $15\choose 5$: it's a binomial
    coefficient of the 15th level.

*** Holes
    This is where the problem gets tricky: holes.
   #+ATTR_LATEX: :align |c|c|c|c|c|
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   |                     |                     | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{blue!25} |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|
   | \cellcolor{blue!25} | \cellcolor{blue!25} |                     |                     |                     |
   |---------------------+---------------------+---------------------+---------------------+---------------------|

   Assume you cannot use the intersection at $(2,4)$. Resolving it
   using combinatorics, we remove paths from $(0,0)$ to $(2,4)$ and
   from $(2,4)$ to $(5,10)$. We then multiply these to get all
   possible combinations, and subtract these from 3003.

   $${15\choose 5} - {6\choose 2} \times {9\choose 3} = 3003 - 1260 = 1743$$

   It is obvious that this problem becomes difficult for two holes
   onward, since we may have to use the inclusion-exclusion principle
   to remove overlaps, extra counts, or undercounts. Consider an extra
   hole at $(4,4)$.
  #+ATTR_LATEX: :align |c|c|c|c|c|
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   |                       |                       | \cellcolor{blue!25} | \cellcolor{blue!25} | \cellcolor{purple!45} |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|
   | \cellcolor{purple!45} | \cellcolor{purple!45} | \cellcolor{red!45}  | \cellcolor{red!45}  |                       |
   |-----------------------+-----------------------+---------------------+---------------------+-----------------------|

  The overlaps make this an annoying problem to solve. This is,
  however, incredibly simple with the inductive/recursive approach:
  just set the paths function to return 0 at the intersections where
  holes exist.

    #+ATTR_LATEX: :options frame=single, framesep=10pt, linenos
    #+BEGIN_SRC cpp :exports both
      #include <iostream>

      int naive_recursion_path(int i, int j)
      {
        if (i == 2 && j == 4) {
          return 0;
        }
        if (i == 0 && j == 0) {
          return 1;
        }
        if (i == 0) {
          return naive_recursion_path(0,j-1);
        }
        if (j == 0) {
          return naive_recursion_path(i-1,0);
        }
        return naive_recursion_path(i-1,j) + naive_recursion_path(i,j-1);
      }

      int main()
      {
        std::cout << naive_recursion_path(5,10) << "\n";
        return 0;
      }

    #+END_SRC

    #+RESULTS:
    : 1743
